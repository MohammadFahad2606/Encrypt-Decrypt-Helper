<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Encrypt / Decrypt Helper — AES (Browser)</title>
    <link
      rel="icon"
      type="image/x-icon"
      href="./img/icon.png"
    />

    <!-- Bootstrap 5 CDN -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />

    <style>
      body {
        background: #f7fafc;
      }
      .card {
        box-shadow: 0 6px 18px rgba(20, 20, 50, 0.06);
      }
      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono",
          monospace;
      }
      .small-muted {
        font-size: 0.85rem;
        color: #6c757d;
      }
    </style>
  </head>
  <body>
    <div class="container py-5">
      <div class="row justify-content-center">
        <div class="col-lg-9">
          <div class="card p-4">
            <div class="d-flex justify-content-between align-items-center mb-3">
              <h4 class="mb-0">Encrypt / Decrypt Helper (Browser-side)</h4>
              <small class="text-muted">AES (Web Crypto)</small>
            </div>

            <p class="small-muted">
              Select algorithm, provide a passphrase (will be used to derive
              key), enter text to encrypt or an encrypted value to decrypt.
              Output format: <code class="mono">ivHex:cipherHex</code>.
            </p>

            <div class="mb-3 row g-2">
              <div class="col-md-5">
                <label class="form-label">Algorithm</label>
                <select id="algSelect" class="form-select">
                  <option value="AES-CBC-256">AES-256-CBC (recommended)</option>
                  <option value="AES-CBC-128">AES-128-CBC</option>
                  <option value="AES-GCM-256">
                    AES-256-GCM (authenticated)
                  </option>
                </select>
                <div class="form-text">
                  AES-GCM provides authentication (preferred when supported).
                  AES-CBC is compatible with many existing systems
                  (non-authenticated).
                </div>
              </div>

              <div class="col-md-7">
                <label class="form-label">Passphrase / Secret</label>
                <input
                  id="passInput"
                  type="password"
                  class="form-control"
                  placeholder="Enter a strong passphrase (min 8 chars) or raw key"
                />
                <div id="passHelp" class="form-text">
                  A passphrase will be used to derive a key via PBKDF2. Do not
                  hardcode secret in front-end for production.
                </div>
              </div>
            </div>

            <ul class="nav nav-tabs" id="tabNav" role="tablist">
              <li class="nav-item" role="presentation">
                <button
                  class="nav-link active"
                  id="enc-tab"
                  data-bs-toggle="tab"
                  data-bs-target="#enc"
                  type="button"
                  role="tab"
                >
                  Encrypt
                </button>
              </li>
              <li class="nav-item" role="presentation">
                <button
                  class="nav-link"
                  id="dec-tab"
                  data-bs-toggle="tab"
                  data-bs-target="#dec"
                  type="button"
                  role="tab"
                >
                  Decrypt
                </button>
              </li>
            </ul>

            <div class="tab-content mt-3">
              <!-- ENCRYPT -->
              <div class="tab-pane fade show active" id="enc" role="tabpanel">
                <div class="mb-3">
                  <label class="form-label">Plaintext (e.g. Mongo URI)</label>
                  <textarea
                    id="plainInput"
                    rows="4"
                    class="form-control"
                    placeholder="mongodb://Admin:..."
                  ></textarea>
                </div>

                <div class="d-flex gap-2 mb-3">
                  <button id="encryptBtn" class="btn btn-primary">
                    Encrypt
                  </button>
                  <button id="genIvBtn" class="btn btn-outline-secondary">
                    Generate Random IV
                  </button>
                  <button id="clearEnc" class="btn btn-outline-danger">
                    Clear
                  </button>
                </div>

                <label class="form-label mt-2">Encrypted output</label>
                <div class="input-group mb-2">
                  <textarea
                    id="encOutput"
                    rows="3"
                    class="form-control mono"
                    readonly
                    placeholder="ivHex:cipherHex"
                  ></textarea>
                  <button id="copyEnc" class="btn btn-outline-secondary">
                    Copy
                  </button>
                </div>
                <div id="encNote" class="small-muted">
                  Format: <code class="mono">ivHex:cipherHex</code>. Keep
                  passphrase secret to decrypt.
                </div>
              </div>

              <!-- DECRYPT -->
              <div class="tab-pane fade" id="dec" role="tabpanel">
                <div class="mb-3">
                  <label class="form-label"
                    >Encrypted value (ivHex:cipherHex)</label
                  >
                  <textarea
                    id="encInput"
                    rows="4"
                    class="form-control mono"
                    placeholder="paste iv:cipher here"
                  ></textarea>
                </div>

                <div class="d-flex gap-2 mb-3">
                  <button id="decryptBtn" class="btn btn-success">
                    Decrypt
                  </button>
                  <button id="clearDec" class="btn btn-outline-danger">
                    Clear
                  </button>
                </div>

                <label class="form-label mt-2">Decrypted output</label>
                <div class="input-group mb-2">
                  <textarea
                    id="decOutput"
                    rows="3"
                    class="form-control"
                    readonly
                    placeholder="decrypted plaintext"
                  ></textarea>
                  <button id="copyDec" class="btn btn-outline-secondary">
                    Copy
                  </button>
                </div>
                <div id="decNote" class="small-muted">
                  If decryption fails, check algorithm, passphrase, and that the
                  encrypted string hasn't been modified.
                </div>
              </div>
            </div>

            <hr />

            <div>
              <h6>Status</h6>
              <div id="status" class="small-muted">Ready</div>
            </div>

            <hr />
            <div class="small-muted">
              Usage notes:
              <ul>
                <li>
                  Passphrase is used with PBKDF2 (SHA-256) to derive the key;
                  you can use a strong passphrase instead of pasting raw 32-byte
                  keys.
                </li>
                <li>
                  For compatibility with Node AES-CBC code, encrypted output is
                  provided as <code>ivHex:cipherHex</code>.
                </li>
                <li>
                  Do NOT expose your passphrase in public or commit to repos.
                </li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Bootstrap & JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

    <script>
      // helper: hex <-> buffer
      const toHex = (buffer) => {
        return Array.from(new Uint8Array(buffer))
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("");
      };
      const fromHex = (hex) => {
        if (!hex) return new Uint8Array();
        const len = hex.length / 2;
        const out = new Uint8Array(len);
        for (let i = 0; i < len; i++)
          out[i] = parseInt(hex.substr(i * 2, 2), 16);
        return out;
      };

      // derive key from passphrase using PBKDF2
      async function deriveKey(passphrase, alg, saltHex = "") {
        if (!passphrase) throw new Error("Passphrase required");
        const enc = new TextEncoder();
        const passKey = await crypto.subtle.importKey(
          "raw",
          enc.encode(passphrase),
          { name: "PBKDF2" },
          false,
          ["deriveKey"]
        );
        // salt: if empty generate one; but for runtime simple use static salt derived from alg name
        const salt = saltHex
          ? fromHex(saltHex)
          : new TextEncoder().encode("salt-" + alg);
        const iterations = 100000;
        const hash = "SHA-256";
        let keyAlgo, keyLen;
        if (alg === "AES-CBC-256" || alg === "AES-GCM-256") {
          keyAlgo = "AES-CBC";
          keyLen = 256;
        } else if (alg === "AES-CBC-128") {
          keyAlgo = "AES-CBC";
          keyLen = 128;
        } else {
          keyAlgo = "AES-CBC";
          keyLen = 256;
        }
        const cryptoKey = await crypto.subtle.deriveKey(
          { name: "PBKDF2", salt, iterations, hash },
          passKey,
          { name: keyAlgo, length: keyLen },
          false,
          ["encrypt", "decrypt"]
        );
        return cryptoKey;
      }

      // encrypt function: returns ivHex:cipherHex
      async function encryptText(plain, passphrase, alg) {
        const iv = crypto.getRandomValues(new Uint8Array(16));
        // derive key
        const key = await deriveKey(passphrase, alg);
        const enc = new TextEncoder();
        const data = enc.encode(plain);
        if (alg === "AES-GCM-256") {
          const ct = await crypto.subtle.encrypt(
            { name: "AES-GCM", iv },
            key,
            data
          );
          return toHex(iv) + ":" + toHex(ct);
        } else {
          // AES-CBC
          const ct = await crypto.subtle.encrypt(
            { name: "AES-CBC", iv },
            key,
            data
          );
          return toHex(iv) + ":" + toHex(ct);
        }
      }

      // decrypt: expects ivHex:cipherHex
      async function decryptText(encrypted, passphrase, alg) {
        if (!encrypted || !encrypted.includes(":"))
          throw new Error(
            "Invalid encrypted format (expected ivHex:cipherHex)"
          );
        const [ivHex, cipherHex] = encrypted.split(":");
        const iv = fromHex(ivHex);
        const ct = fromHex(cipherHex);
        const key = await deriveKey(passphrase, alg);
        if (alg === "AES-GCM-256") {
          const plainBuf = await crypto.subtle.decrypt(
            { name: "AES-GCM", iv },
            key,
            ct
          );
          return new TextDecoder().decode(plainBuf);
        } else {
          const plainBuf = await crypto.subtle.decrypt(
            { name: "AES-CBC", iv },
            key,
            ct
          );
          return new TextDecoder().decode(plainBuf);
        }
      }

      // DOM bindings
      const algSelect = document.getElementById("algSelect");
      const passInput = document.getElementById("passInput");
      const plainInput = document.getElementById("plainInput");
      const encryptBtn = document.getElementById("encryptBtn");
      const encOutput = document.getElementById("encOutput");
      const copyEnc = document.getElementById("copyEnc");
      const genIvBtn = document.getElementById("genIvBtn");
      const status = document.getElementById("status");

      const encInput = document.getElementById("encInput");
      const decryptBtn = document.getElementById("decryptBtn");
      const decOutput = document.getElementById("decOutput");
      const copyDec = document.getElementById("copyDec");

      function setStatus(msg, ok = true) {
        status.textContent = msg;
        status.style.color = ok ? "#0b8457" : "#b02a37";
      }

      encryptBtn.addEventListener("click", async () => {
        try {
          setStatus("Encrypting...");
          const alg = algSelect.value;
          const pass = passInput.value;
          const plain = plainInput.value;
          if (!pass || pass.length < 4) {
            setStatus("Passphrase too short (min 4 chars).", false);
            return;
          }
          if (!plain) {
            setStatus("Enter plaintext to encrypt.", false);
            return;
          }
          const cipher = await encryptText(plain, pass, alg);
          encOutput.value = cipher;
          setStatus("Encryption success ✓");
        } catch (e) {
          console.error(e);
          setStatus("Encrypt error: " + (e.message || e), false);
        }
      });

      decryptBtn.addEventListener("click", async () => {
        try {
          setStatus("Decrypting...");
          const alg = algSelect.value;
          const pass = passInput.value;
          const encVal = encInput.value.trim();
          if (!pass || pass.length < 4) {
            setStatus("Passphrase too short (min 4 chars).", false);
            return;
          }
          if (!encVal) {
            setStatus("Paste encrypted value to decrypt.", false);
            return;
          }
          const out = await decryptText(encVal, pass, alg);
          decOutput.value = out;
          setStatus("Decryption success ✓");
        } catch (e) {
          console.error(e);
          setStatus("Decrypt error: " + (e.message || e), false);
        }
      });

      copyEnc.addEventListener("click", async () => {
        const txt = encOutput.value;
        if (!txt) return setStatus("Nothing to copy", false);
        await navigator.clipboard.writeText(txt);
        setStatus("Encrypted text copied to clipboard");
      });

      copyDec.addEventListener("click", async () => {
        const txt = decOutput.value;
        if (!txt) return setStatus("Nothing to copy", false);
        await navigator.clipboard.writeText(txt);
        setStatus("Decrypted text copied to clipboard");
      });

      document.getElementById("clearEnc").addEventListener("click", () => {
        plainInput.value = "";
        encOutput.value = "";
        setStatus("Cleared");
      });
      document.getElementById("clearDec").addEventListener("click", () => {
        encInput.value = "";
        decOutput.value = "";
        setStatus("Cleared");
      });

      // convenience: generate random IV shows nothing to user, but kept for future use
      document.getElementById("genIvBtn").addEventListener("click", () => {
        const iv = crypto.getRandomValues(new Uint8Array(16));
        const hex = toHex(iv);
        // put iv as prefix of output field for user's interest (not typically needed)
        encOutput.value = hex + ":";
        setStatus(
          "Random IV generated (prefilled in encrypted output). Note: actual encryption will replace it."
        );
      });
    </script>
  </body>
</html>
